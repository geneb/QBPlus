{-------------------------------------------------------------------------
                                    mvh

               Unit to display memory viewer help information

                  Written for Borland Turbo Pascal V 6.0

                     Copyright 1991, by John H. Eckert
                           All Rights Reserved


                                                   ... a component of the
                                                   QuickBasic Programmer
                                                   Desk Accessories ...
-------------------------------------------------------------------------}
{ History:           
01/11/91   0.20   Pulled out of the mv module.
06/24/91   0.95   Windows 386 protection added to memory viewer.
}
{-------------------------------------------------------------------------}
{$F+}                               { Far calls needed for overlays }
{$O+}                               { Unit may be overlaid          }
UNIT mvh;

{ Increased granularity of overlaid units permits reduction in overlay buffer
size,and thereby the resident memory requirements overall.  Thus, we build a
separate overlay unit to display help information.
}

{==========================================================================}
{================================= Interface ==============================}
{==========================================================================}
INTERFACE


USES Crt, Dos, pdaSubs;

PROCEDURE mvHelpScreen;             { Memory viewer help screen            }
FUNCTION ShowWin386XMS: Boolean;    { Warning on XMS viewing in Win386     }


{==========================================================================}
{============================ Implementation ==============================}
{==========================================================================}

IMPLEMENTATION

{=========================== mvHelpScreen ==============================}
{ Displays help for the user. Lower prompt line is cleared on entry and
restored on exit. }
PROCEDURE mvHelpScreen;
Begin
ClrScr;
Box(2, 1, 34, 18);                                 { Make box          }
Window( ULCol + 2, ULRow, LLCol, LLRow );          { Column left info  }

{ Left column gets Navigation }
Writeln;
Writeln('컴컴컴컴컴 Navigation 컴컴컴컴컴');
Writeln(#27#26,'     Move by one display line');
Writeln(#24#25,'     Move one display screen');
Writeln('PgUpDn Move by a segment/page'); 
Writeln('Home   Go to offset start'); 
Writeln('End    Go to offset end');
Writeln('<>     Move by Huge 1 meg block');
Writeln('        or Handle in EMS or XMS'); 
Writeln('H      Enter Huge/Handle value'); 
Writeln('S      Enter Segment/page value');
Writeln('O      Enter Offset value');
Writeln;
Writeln('Huge/Segment/Offset addresses');
Writeln('take on their equivalent values');
Writeln('in linear address display modes');

Window( ULCol + 37, ULRow, LLCol, LLRow );          { Column right box   }
Box(1, 1, 34, 18);                                  { Make box           }
Window( ULCol + 38, ULRow, LLCol, LLRow );          { Column right info  }
{GotoXY(1, 1);}

{ Do address mode information }
Writeln;
Writeln('컴컴컴컴  Address Modes  컴컴컴');
Writeln('Real/Linear - consecutive from ');
Writeln('zero to top of regular and any');
Writeln('installed extended memory.');
Writeln;
Writeln('; - toggles linear addresses');
Writeln('E - EMS handles/pages/offsets');
Writeln('X - XMS handles/linear offsets');
Writeln('P - I/O ports CAUTION: see docs');
Writeln('C - CMOS configuration area');
Writeln;
Writeln('컴컴컴컴  Viewing Modes  컴컴컴');
Writeln('B - Bytes       W - Words');
Writeln('L - Long        V - Vectors');
Writeln('A - Ascii       R - Real time');
Writeln('I - Integer (signed decimal)');
Window( ULCol, ULRow, LLCol, LLRow );           { Restore normal window      }

{ Clear the memory display prompt, put ours up and wait for keypress to exit }
ClearPrompt;
GotoXY(34,19); Write('< OK >'#8#8#8#8); cursor_on;
Repeat Until GetKey IN [#27,#13]; cursor_off;

BorderTitlePrompt(Title,       { Show border, title and prompt.}
                  Prompt);

ClrScr;

End; { mvHelp }



{=========================== ShowWin386XMS ==============================}
{  Displays warning when XMS is accessed for viewing where we are running
   under Windows 386 Enhanced. Permits user to back out and avoid System
   Integrity violation generated by Win386 when data is moved from an XMS
   handle that does not belong to us. The violation is not generated on the
   Move intself, but on the next access to that handle.  This routine also
   allows user to disable further warnings if he decides to proceed at his
   own risk.

   External access:
         Variables                           Calls
      NoWin386XMS       W                 ClrScr
                                          Box
                                          GetUpKey
}
FUNCTION ShowWin386XMS: Boolean;    { Warning on XMS viewing in Win386     }
Var
WindMinSave          : Word;        { Storage for preserving screen        }
WindMaxSave          : Word;        { window setting.                      }

Begin
{ Draw our frame within the main window }
ClrScr;
Box(4, 2, LLCol - ULCol - 5, LLRow - ULRow - 3);
GotoXY(32, 2); Write(' WARNING ');
GotoXY(16, LLRow - ULRow - 2);
Write(' Press key corresponding to desired choice ');

{ Shrink print window within our frame }
WindMaxSave := WindMax;               { Preserve existing window coords.   }
WindMinSave := WindMin;
{ Our size...        }
Inc(WindMin, $308);                   { Shrink window by 3 rows and 8      }
Dec(WindMax, $408);                   { columns, 4 rows/8 columns          }

Repeat
   ClrScr;
   Writeln('Attempting to view memory in an XMS handle that belongs');
   Writeln('to Windows, or to another application, may produce a');
   Writeln('"System Integrity Violation" under Windows 386.  Such a');
   Writeln('violation will halt this program as well as QuickBASIC');
   Writeln('without affording you any opportunity to save data or');
   Writeln('any loaded QuickBASIC program.');
   Writeln;
   Writeln('   <C>ancel request to view XMS');
   Writeln('   <V>iew XMS anyway');
   Writeln('   <D>isable future warnings and view XMS');

   Cursor_on;
   GotoXY(5, 8); Ch := GetUpKey;
   Cursor_off;
Until Ch IN [#27, #13, 'C', 'V', 'D'];

{ Set up return code }
If Ch IN ['V', 'D'] Then
   Begin
   ShowWin386XMS := True;
   If Ch = 'D' Then NoWin386XMS := False;
   End
Else
   ShowWin386XMS := False;

{ Restore print window  }
WindMax := WindMaxSave;
WindMin := WindMinSave;

{Clear our keypress value}
Ch := #0;

End;


End.
